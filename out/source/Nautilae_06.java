/* autogenerated by Processing revision 1292 on 2023-10-11 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.svg.*;
import controlP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Nautilae_06 extends PApplet {





boolean debug_mode = true;

// Controls
ControlP5 cp5;
Slider slider_line_iterations, slider_points, slider_speed, slider_line_noise, slider_point_noise, slider_vortex_rotation, slider_vortex_iterations;
Toggle toggle_vortex, toggle_debug;
Button button_generate, button_reset, button_record;

// Interface status
boolean show_controls = true;
boolean record = false;

// Vectors
PVector vs1, vs2, ve1, ve2, hs1, hs2, he1, he2;

// Creatures
Creature creature_one; 

// Sketch Parameters
PImage vortex_img;
boolean vortex_effect = false;
int vortex_iterations = 5;
int sketch_size = 600;
int border = 75;
int double_border = 2 * border;

// Creature Default Properties
float vortex_rotation = 5.0f;
float moving_speed = 1.0f;
float line_noise_magnitude = 0.0f;
float point_noise_magnitude = 0.0f;
int line_iterations = 10;
int line_points = 20;

public void setup() {
    // Setup the stage
    /* smooth commented out by preprocessor */;
    /* size commented out by preprocessor */;
    strokeCap(ROUND);
    strokeJoin(ROUND);
    ellipseMode(CENTER);
    noiseSeed(100);

    // Create the controls
    cp5 = new ControlP5(this);
    cp5.setAutoDraw(false);
    setupControls();

    // Create the first creature
    creature_one = newCreature(); 
}
    
public void draw() {
    background(255);

    // Start recording
    if (record) {
		beginRecord(SVG, "export/objects-" + dateString() + ".svg");
    }

    drawCreature();

    // End SVG recording...
	if (record) {
		endRecord();
		record = false;
	}
    drawControls();
}

public void keyPressed() {
    // Recreate creature
    if (key == 'r' || key == 'R') {
        createCreature();
    }

    // Show/Hide controls
    if (key == 'c' || key == 'C') {
        toggleControls();
    }
}

public void createCreature() {
    updateControlValues();
    creature_one = newCreature(); 
}

public Creature newCreature() {
    // Create the creature with all the parameters
    Creature temp_creature = new Creature(
                                    line_iterations, 
                                    line_points, 
                                    moving_speed, 
                                    line_noise_magnitude, 
                                    point_noise_magnitude
                                ); 
    return temp_creature;
}

public PVector randomPos() {
    PVector p = new PVector(random(width) - width * 0.5f, random(height) - height * 0.5f);
    return p;
}

public String dateString() {
    String dateString = year() + "-" + nf(month(), 2) + "-" + nf(day(), 2)+ "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);
    return dateString;
}
public void setupControls() {
	// Slider for the number of iterations between the vectors
    slider_line_iterations = cp5.addSlider("setLineIterations")
        .setLabel("Line iterations")
        .setValue(line_iterations)
        .setRange(1,30)
        .setNumberOfTickMarks(30)
        .setPosition(20,20)
        .setSize(200,10)
        .setVisible(show_controls)
        ;

    // Slider for the number of points draw for each line
    slider_speed = cp5.addSlider("setMovingSpeed")
        .setLabel("Moving speed")
        .setValue(moving_speed)
        .setRange(0,10)
        .setNumberOfTickMarks(11)
        .setPosition(20,40)
        .setSize(200,10)
        .setVisible(show_controls)
        ;

    // Slider for the number of points draw for each line
    slider_points = cp5.addSlider("setPointsPerLine")
        .setLabel("Points per line")
        .setValue(line_points)
        .setRange(2,1000)
        .setNumberOfTickMarks(999)
        .setPosition(20,60)
        .setSize(200,10)
        .setVisible(show_controls)
        ;

    // Toggle for the vortex effect
    toggle_vortex = cp5.addToggle("setVortex")
        .setLabel("Vortex")
        .setValue(vortex_effect)
        .setPosition(20,80)
        .setSize(90,10)
        .setVisible(show_controls);

    // Toggle for the vortex effect
    toggle_debug = cp5.addToggle("setDebug")
        .setLabel("Debug")
        .setValue(debug_mode)
        .setPosition(120,80)
        .setSize(90,10)
        .setVisible(show_controls);

    // Slider to adjust the rotation of each vortex iteration
    slider_vortex_rotation = cp5.addSlider("setVortexRotation")
        .setLabel("Vortex Rotation")
        .setValue(vortex_rotation)
        .setRange(0,90)
        .setPosition(20,100)
        .setSize(200,10)
        .setVisible(show_controls);

    // Slider to adjust the numbers of vortex iterations
    slider_vortex_iterations = cp5.addSlider("setVortexIterations")
        .setLabel("Vortex Iterations")
        .setValue(vortex_iterations)
        .setRange(1,10)
        .setPosition(20,120)
        .setSize(200,10)
        .setVisible(show_controls);

    // Slider to adjust the amount of y-noise added to the points
    slider_line_noise = cp5.addSlider("setLineNoise")
        .setLabel("Line noise")
        .setValue(line_noise_magnitude)
        .setRange(0,200)
        .setPosition(20,160)
        .setSize(200,10)
        .setVisible(show_controls);

    // Slider to adjust the amount of y-noise added to the points
    slider_point_noise = cp5.addSlider("setPointNoise")
        .setLabel("Point noise")
        .setValue(point_noise_magnitude)
        .setRange(0,25)
        .setPosition(20,180)
        .setSize(200,10)
        .setVisible(show_controls);

    // create a new button with name 'buttonA'
    button_generate = cp5.addButton("createCreature")
        .setLabel("Create")
        .setValue(0)
        .setPosition(width-80,20)
        .setSize(60,50)
        .setVisible(show_controls);
    
    button_record = cp5.addButton("saveSVG")
		.setPosition(width-80,80)
		.setSize(60, 20);
}

// Toggle Controls
public void showControls() {
    hideControls();
    toggleControls(true);
}
public void hideControls() {
    toggleControls(false);
}
public void toggleControls() {
    show_controls = !show_controls;
    toggleControls(show_controls);
}
public void toggleControls(boolean show_hide) {
    show_controls = show_hide;

    // show and hide default controls
    button_generate.setVisible(show_controls);
    button_reset.setVisible(show_controls);
    slider_line_iterations.setVisible(show_controls); 
}

// Update parameters 
public void updateControlValues() {
    vortex_effect = PApplet.parseBoolean(PApplet.parseInt(toggle_vortex.getValue()));
    debug_mode = PApplet.parseBoolean(PApplet.parseInt(toggle_debug.getValue()));
    vortex_rotation = slider_vortex_rotation.getValue();
    vortex_iterations = PApplet.parseInt(slider_vortex_iterations.getValue());
    moving_speed = slider_speed.getValue();
    line_noise_magnitude = slider_line_noise.getValue();
    line_iterations = PApplet.parseInt(slider_line_iterations.getValue());
    line_points = PApplet.parseInt(slider_points.getValue());
    point_noise_magnitude = slider_point_noise.getValue();
}

// Update parameters 
public void resetControls() {
    toggle_vortex.setValue(0);
    slider_vortex_rotation.setValue(0.0f);
    slider_vortex_iterations.setValue(0.0f);
    slider_speed.setValue(0);
    slider_line_noise.setValue(0);
    slider_line_iterations.setValue(1);
    slider_points.setValue(400);
    slider_point_noise.setValue(0);
    hideControls();
    createCreature();
}


public void saveSVG() {
	record = true;
}
class Creature { 
    
    // Vector 1: Start, Handler Start, Handler End, End
    
    
    PVector v1, v2, v3, v4;
    PVector h1, h2, h3, h4;
    PVector c1, c2, c3, c4;
    PVector n1, n2, n3, n4;
    
    // Moving Vector
    PVector m1, m2, m3, m4;
    
    // Line properties and boundaries
    int line_iterations = 15;
    int line_points = 400;
    int stroke_weight = 5;
    
    // Noise
    float line_interpolation = 1 / PApplet.parseFloat(line_iterations);
    float line_noise_magnitude = 0.0f;
    float point_noise_magnitude = 0.0f;
    float noise_progress = 0.0f;
    float moving_speed = 3.0f;
    float decrease_rate = 0.98f;
    int noise_seed = 1;
    
    Creature(int iterations, int points, float speed, float line_magnitude, float point_magnitude) { 
        // Creature specific noise seed
        noise_seed = floor(random(100));
        noiseDetail(1);
        
        // Transfer properties to local variables
        line_iterations = iterations;
        line_points = points;
        moving_speed = speed;
        line_noise_magnitude = line_magnitude;
        point_noise_magnitude = point_magnitude;
        
        // Derived properties
        line_interpolation = 1 / PApplet.parseFloat(line_iterations);
        
        
        // Vector points
        v1 = randomPos(); 
        v2 = randomPos(); 
        v3 = randomPos();
        v4 = randomPos();
        
        // Handle points
        h1 = randomPos(); 
        h2 = randomPos(); 
        h3 = randomPos();
        h4 = randomPos();
        
        // Control points
        c1 = randomPos();
        c2 = randomPos();
        c3 = randomPos();
        c4 = randomPos();
        
        if (debug_mode) {
            v1 = new PVector( -200, -200);
            v3 = new PVector(200, -200);
            v2 = new PVector( -200,200);
            v4 = new PVector(200,200);
            
            h1 = new PVector( -100, -300);
            h3 = new PVector(100, -300);
            h2 = new PVector( -100,300);
            h4 = new PVector(100,300);
            
            c1 = new PVector( -100, -100);
            c2 = new PVector(100, -100);
            c3 = new PVector( -100,100);
            c4 = new PVector(100,100);
        }

        
        // Set random movement vectors
        m1 = new PVector(random( -moving_speed, moving_speed), random( -moving_speed, moving_speed));
        m2 = new PVector(random( -moving_speed, moving_speed), random( -moving_speed, moving_speed));
        m3 = new PVector(random( -moving_speed, moving_speed), random( -moving_speed, moving_speed));
        m4 = new PVector(random( -moving_speed, moving_speed), random( -moving_speed, moving_speed));
    } 
    
    public void update() { 
        // Update the progress of the creature
        // noiseSeed(noise_seed);
        // noise_progress = noise_progress + .01;
        updateNoise();

        // Sum up vectors
        v1.add(m1); c1.add(m2); h1.add(m3);
        v2.add(m2); c2.add(m3); h2.add(m4);
        v3.add(m3); c3.add(m4); h3.add(m1);
        v4.add(m4); c4.add(m1); h4.add(m2);

        draw();
        
        // Decrease movement over time
        m1.mult(decrease_rate);
        m2.mult(decrease_rate);
        m3.mult(decrease_rate);
        m4.mult(decrease_rate);
    } 
    
    // Draw the creature
    public void draw() {
        
        
        // Create several lines by interpolating start and end vector
        int numVortex = vortex_effect ? vortex_iterations : 1;
        
        pushMatrix();
        translate(width * 0.5f, height * 0.5f);
        
        if (debug_mode) {
            drawHandles();
            
        }   
        
        // Lines
        
        
        for (int a = 1; a <= numVortex; a++) {
            // Draw the interpolation lines
            for (int i = 0; i < line_iterations; i++) {
                
                float t = map(i, 0, line_iterations - 1, 0, 1);
                
                // Interpolate vectors for each iteration, multiply the interpolation factor
                float p1x = bezierPoint(v1.x, c1.x, c2.x, v3.x, t);
                float p1y = bezierPoint(v1.y, c1.y, c2.y, v3.y, t);
                float h1x = bezierPoint(h1.x, c1.x, c2.x, h3.x, t);
                float h1y = bezierPoint(h1.y, c1.y, c2.y, h3.y, t);
                
                float p2x = bezierPoint(v2.x, c3.x, c4.x, v4.x, t);
                float p2y = bezierPoint(v2.y, c3.y, c4.y, v4.y, t);
                float h2x = bezierPoint(h2.x, c3.x, c4.x, h4.x, t);
                float h2y = bezierPoint(h2.y, c3.y, c4.y, h4.y, t);
                
                // Draw line as circles with different sizes
                
                beginShape();
                for (int j = 0; j <= line_points; j++) {
                    // Interpolate circle size for each point
                    float point_position = map(j, 0, line_points - 1, 0, 1);
                    float x = bezierPoint(p1x, h1x, h2x, p2x, point_position);
                    float y = bezierPoint(p1y, h1y, h2y, p2y, point_position);
                    
                    y += noisePlusMinus(line_noise_magnitude, i, j, 0.01f);
                    y += noisePlusMinus(point_noise_magnitude, i, j, 1);
                    x += noisePlusMinus(line_noise_magnitude, x, y, 0.01f);
                    x += noisePlusMinus(point_noise_magnitude, x, y, 1);

                    if (debug_mode) {
                        noStroke();
                        fill(128,128,128);
                        circle(x, y, 10);
                    }
                    
                    vertex(x, y);
                }

                stroke(1);
                strokeWeight(stroke_weight);
                noFill();

                endShape();
            }
            // Apply transform
            rotate(radians(vortex_rotation));
            scale(1 - ((float) a / vortex_iterations * 0.5f));
        }
        popMatrix();
    }
    
    // Perlinnoise (Amplitude, X, Y, Factor)
    public float noisePlusMinus(float amp, float x, float y, float f) {
        float n = amp * noise(y * f, x) - amp * 0.5f;
        return(n);
    }

    public void updateNoise() {
        n1 = new PVector(noise(v1.x, v1.y), noise(h1.x, h1.y));
        n2 = new PVector(noise(v2.x, v2.y), noise(h2.x, h2.y));
        n3 = new PVector(noise(v3.x, v3.y), noise(h3.x, h3.y));
        n4 = new PVector(noise(v4.x, v4.y), noise(h4.x, h4.y));

        n1.mult(10);
        n2.mult(10);
        n3.mult(10);
        n4.mult(10);
    }
    
    // Traces
    public void drawHandles() {
        // Handles
        noStroke();
        fill(255,0,0);
        circle(v1.x, v1.y, 60);
        circle(v3.x, v3.y, 60);
        circle(v2.x, v2.y, 60);
        circle(v4.x, v4.y, 60);
        
        fill(0,255,0);
        circle(h1.x, h1.y, 40);
        circle(h2.x, h2.y, 40);
        circle(h3.x, h3.y, 40);
        circle(h4.x, h4.y, 40);
        
        fill(0,0,255);
        circle(c1.x, c1.y, 20);
        circle(c2.x, c2.y, 20);
        circle(c3.x, c3.y, 20);
        circle(c4.x, c4.y, 20);
        
        noFill();
        strokeWeight(1);
        stroke(255,0,0);
        
        // Bezier Lines
        line(v1.x, v1.y, h1.x, h1.y);
        line(h1.x, h1.y, h2.x, h2.y);
        line(h2.x, h2.y, v2.x, v2.y);
        
        line(v3.x, v3.y, h3.x, h3.y);
        line(h3.x, h3.y, h4.x, h4.y);
        line(h4.x, h4.y, v4.x, v4.y);
        
        // Distort controls
        stroke(0,0,255);
        line(v1.x, v1.y, c1.x, c1.y);
        line(v3.x, v3.y, c2.x, c2.y);
        line(v2.x, v2.y, c3.x, c3.y);
        line(v4.x, v4.y, c4.x, c4.y);
    }
} 
public void drawCreature() {
	// Update every frame
    blendMode(NORMAL);
    creature_one.update();
}

public void drawControls() {
	// Draw controls
    blendMode(NORMAL);
    cp5.draw();
}


  public void settings() { size(800, 800);
smooth(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Nautilae_06" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
