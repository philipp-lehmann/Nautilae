/* autogenerated by Processing revision 1292 on 2023-10-12 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.svg.*;
import controlP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Nautilae_06 extends PApplet {





boolean debug_mode = true;
boolean show_handles = true;

// Controls
ControlP5 cp5;
Slider slider_line_iterations, slider_points, slider_vortex_rotation, slider_vortex_iterations, slider_noise_scale, slider_noise_factor, slider_noise_falloff;
Toggle toggle_vortex, toggle_debug;
Button button_generate, button_record;

// Interface status
boolean show_controls = true;
boolean record = false;

// Vectors
PVector vs1, vs2, ve1, ve2, hs1, hs2, he1, he2;

// Creatures
Creature creature_one; 

// Sketch Parameters
PImage vortex_img;
boolean vortex_effect = false;
int vortex_iterations = 5;
int sketch_size = 600;
int border = 75;
int double_border = 2 * border;

// Creature Default Properties
float vortex_rotation = 5.0f;
float moving_speed = 1.0f;
int line_iterations = 10;
int line_points = 20;
float noise_falloff = 0.8f;
float noise_scale = 15.0f;
float noise_factor = 0.02f;

public void setup() {
    // Setup the stage
    /* smooth commented out by preprocessor */;
    /* size commented out by preprocessor */;
    strokeCap(ROUND);
    strokeJoin(ROUND);
    ellipseMode(CENTER);
    noiseSeed(100);
    noiseDetail(8, noise_falloff);

    // Create the controls
    cp5 = new ControlP5(this);
    cp5.setAutoDraw(false);
    setupControls();

    // Create the first creature
    creature_one = newCreature(); 
}
    
public void draw() {
    background(255);

    // Start recording
    if (record) {
		beginRecord(SVG, "export/objects-" + dateString() + ".svg");
    }

    // Update every frame
    blendMode(NORMAL);
    creature_one.update();
    creature_one.draw();
    creature_one.checkSelection();
    

    // End SVG recording...
	if (record) {
		endRecord();
		record = false;
	}

    creature_one.drawHandles();

    // Draw controls
    blendMode(NORMAL);
    cp5.draw();
}

public void keyPressed() {
    // Recreate creature
    if (key == 'r' || key == 'R') {
        createCreature();
    }

    // Show/Hide controls
    if (key == 'c' || key == 'C') {
        toggleControls();
    }
}

public void createCreature() {
    creature_one = newCreature(); 
}

public Creature newCreature() {
    // Create the creature with all the parameters
    Creature temp_creature = new Creature(
                                    line_iterations, 
                                    line_points, 
                                    moving_speed
                                ); 
    return temp_creature;
}

public PVector randomPos() {
    PVector p = new PVector(random(width) - width * 0.5f, random(height) - height * 0.5f);
    return p;
}

public String dateString() {
    String dateString = year() + "-" + nf(month(), 2) + "-" + nf(day(), 2)+ "-" + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2);
    return dateString;
}
public void setupControls() {
    // Slider for the number of iterations between the vectors
    slider_line_iterations = cp5.addSlider("setLineIterations")
       .setLabel("Line iterations")
       .setValue(line_iterations)
       .setRange(1,30)
       .setNumberOfTickMarks(30)
       .setPosition(20,20)
       .setSize(200,10)
       .setVisible(show_controls)
       ;
    
    // Slider for the number of points draw for each line
    slider_points = cp5.addSlider("setPointsPerLine")
       .setLabel("Points per line")
       .setValue(line_points)
       .setRange(2,1000)
       .setNumberOfTickMarks(999)
       .setPosition(20,60)
       .setSize(200,10)
       .setVisible(show_controls)
       ;
    
    // Toggle for the vortex effect
    toggle_vortex = cp5.addToggle("setVortex")
       .setLabel("Vortex")
       .setValue(vortex_effect)
       .setPosition(20,80)
       .setSize(90,10)
       .setVisible(show_controls);
    
    // Toggle for the vortex effect
    toggle_debug = cp5.addToggle("setDebug")
       .setLabel("Debug")
       .setValue(debug_mode)
       .setPosition(120,80)
       .setSize(90,10)
       .setVisible(show_controls);
    
    // Slider to adjust the rotation of each vortex iteration
    slider_vortex_rotation = cp5.addSlider("setVortexRotation")
       .setLabel("Vortex Rotation")
       .setValue(vortex_rotation)
       .setRange(0,90)
       .setPosition(20,100)
       .setSize(200,10)
       .setVisible(show_controls);
    
    // Slider to adjust the numbers of vortex iterations
    slider_vortex_iterations = cp5.addSlider("setVortexIterations")
       .setLabel("Vortex Iterations")
       .setValue(vortex_iterations)
       .setRange(1,10)
       .setPosition(20,120)
       .setSize(200,10)
       .setVisible(show_controls);

    // Slider to adjust the noise falloff for the details
    slider_noise_scale = cp5.addSlider("setNoiseScale")
       .setLabel("Noise scale")
       .setValue(noise_scale)
       .setRange(0,25)
       .setPosition(20,200)
       .setSize(200,10)
       .setVisible(show_controls);

    // Slider to adjust the noise offset radius
    slider_noise_falloff = cp5.addSlider("setNoiseFalloff")
       .setLabel("Noise falloff")
       .setValue(noise_falloff)
       .setRange(0,1)
       .setPosition(20,220)
       .setSize(200,10)
       .setVisible(show_controls);

    // Slider to adjust the noise detail level
    slider_noise_factor = cp5.addSlider("setNoiseFactor")
       .setLabel("Noise factor")
       .setValue(noise_factor)
       .setRange(0.001f,0.1f)
       .setPosition(20,240)
       .setSize(200,10)
       .setVisible(show_controls);
    
    // create a new button with name 'buttonA'
    button_generate = cp5.addButton("createCreature")
       .setLabel("Create")
       .setValue(0)
       .setPosition(width - 80,20)
       .setSize(60,50)
       .setVisible(show_controls);
    
    button_record = cp5.addButton("saveSVG")
        	.setPosition(width - 80,80)
        	.setSize(60, 20);
}

// Toggle Controls
public void showControls() {
    hideControls();
    toggleControls(true);
}
public void hideControls() {
    toggleControls(false);
}
public void toggleControls() {
    show_controls = !show_controls;
    show_handles = show_controls;
    toggleControls(show_controls);
}
public void toggleControls(boolean show_hide) {
    show_controls = show_hide;
    
    // Show and hide default controls
    button_generate.setVisible(show_controls);
    button_record.setVisible(show_controls);
    slider_line_iterations.setVisible(show_controls); 
    slider_points.setVisible(show_controls); 
    slider_vortex_rotation.setVisible(show_controls); 
    slider_vortex_iterations.setVisible(show_controls); 
    slider_noise_scale.setVisible(show_controls); 
    slider_noise_factor.setVisible(show_controls); 
    slider_noise_falloff.setVisible(show_controls);
    toggle_vortex.setVisible(show_controls);
    toggle_debug.setVisible(show_controls);
}

// Control event
public void controlEvent(ControlEvent theControlEvent) {
   if (creature_one != null) {
      updateControlValues();
      creature_one.line_iterations = line_iterations;
      creature_one.line_points = line_points;
   }
}

// Update parameters 
public void updateControlValues() {
    vortex_effect = PApplet.parseBoolean(PApplet.parseInt(toggle_vortex.getValue()));
    debug_mode = PApplet.parseBoolean(PApplet.parseInt(toggle_debug.getValue()));
    vortex_rotation = slider_vortex_rotation.getValue();
    vortex_iterations = PApplet.parseInt(slider_vortex_iterations.getValue());
    line_iterations = PApplet.parseInt(slider_line_iterations.getValue());
    line_points = PApplet.parseInt(slider_points.getValue());
    noise_falloff = slider_noise_falloff.getValue();
    noise_scale = slider_noise_scale.getValue();
    noise_factor = slider_noise_factor.getValue();
    noiseDetail(8, noise_falloff);
}

// Update parameters 
public void resetControls() {
    toggle_vortex.setValue(0);
    slider_vortex_rotation.setValue(0.0f);
    slider_vortex_iterations.setValue(0.0f);
    slider_speed.setValue(0);
    slider_line_iterations.setValue(1);
    slider_points.setValue(400);
    hideControls();
    createCreature();
}


public void saveSVG() {
    record = true;
}
class Creature { 
    
    // Points
    PVector[] vectors = new PVector[12];
    PVector v1, v2, v3, v4;
    PVector h1, h2, h3, h4;
    PVector c1, c2, c3, c4;
    
    // Movements
    PVector m1, m2, m3, m4;
    PVector selected_vector = null;
    
    // Line properties and boundaries
    int line_iterations = 15;
    int line_points = 400;
    int stroke_weight = 5;
    
    // Noise
    float line_interpolation = 1 / PApplet.parseFloat(line_iterations);
    float noise_progress = 0.0f;
    float moving_speed = 5.0f;
    float decrease_rate = 0.98f;
    int noise_seed = 1;

    // Appearance
    int handle_size = 15;
    
    Creature(int iterations, int points, float speed) { 
        
        // Creature specific noise seed
        noise_seed = floor(random(100));
        noiseDetail(1);
        
        // Transfer properties to local variables
        line_iterations = iterations;
        line_points = points;
        moving_speed = speed;
        
        // Derived properties
        line_interpolation = 1 / PApplet.parseFloat(line_iterations);
        
        // Vector points
        v1 = randomPos(); 
        v2 = randomPos(); 
        v3 = randomPos();
        v4 = randomPos();
        
        // Handle points
        h1 = randomPos(); 
        h2 = randomPos(); 
        h3 = randomPos();
        h4 = randomPos();
        
        // Control points
        c1 = randomPos();
        c2 = randomPos();
        c3 = randomPos();
        c4 = randomPos();
        
        if (debug_mode) {
            v1 = new PVector( -200, -200);
            v3 = new PVector(200, -200);
            v2 = new PVector( -200,200);
            v4 = new PVector(200,200);
            
            h1 = new PVector( -100, -300);
            h3 = new PVector(100, -300);
            h2 = new PVector( -100,300);
            h4 = new PVector(100,300);
            
            c1 = new PVector( -100, -100);
            c2 = new PVector(100, -100);
            c3 = new PVector( -100,100);
            c4 = new PVector(100,100);
        }
        
        // Set random movement vectors
        m1 = new PVector(random( -moving_speed, moving_speed), random( -moving_speed, moving_speed));
        m2 = new PVector(random( -moving_speed, moving_speed), random( -moving_speed, moving_speed));
        m3 = new PVector(random( -moving_speed, moving_speed), random( -moving_speed, moving_speed));
        m4 = new PVector(random( -moving_speed, moving_speed), random( -moving_speed, moving_speed));
        
        assignVectorArray();
    } 
    
    public void update() { 
        // Sum up vectors
        v1.add(m1); c1.add(m2); h1.add(m3);
        v2.add(m2); c2.add(m3); h2.add(m4);
        v3.add(m3); c3.add(m4); h3.add(m1);
        v4.add(m4); c4.add(m1); h4.add(m2);
        
        // Decrease movement over time
        m1.mult(decrease_rate);
        m2.mult(decrease_rate);
        m3.mult(decrease_rate);
        m4.mult(decrease_rate);
    } 
    
    // Draw creature
    public void draw() {

        pushMatrix();
        translate(width * 0.5f, height * 0.5f);

        // Vortex settings
        int numVortex = vortex_effect ? vortex_iterations : 1;
        
        // Lines
        for (int a = 1; a <= numVortex; a++) {
            // Draw the interpolation lines
            for (int i = 0; i < line_iterations; i++) {
                
                float t = map(i, 0, line_iterations - 1, 0, 1);
                
                // Interpolate vectors for each iteration, multiply the interpolation factor
                float p1x = bezierPoint(v1.x, c1.x, c2.x, v3.x, t);
                float p1y = bezierPoint(v1.y, c1.y, c2.y, v3.y, t);
                
                float h1x = bezierPoint(h1.x, c1.x, c2.x, h3.x, t);
                float h1y = bezierPoint(h1.y, c1.y, c2.y, h3.y, t);
                
                float p2x = bezierPoint(v2.x, c3.x, c4.x, v4.x, t);
                float p2y = bezierPoint(v2.y, c3.y, c4.y, v4.y, t);
                
                float h2x = bezierPoint(h2.x, c3.x, c4.x, h4.x, t);
                float h2y = bezierPoint(h2.y, c3.y, c4.y, h4.y, t);
                
                // Draw line as circles with different sizes
                beginShape();
                
                for (int j = 0; j <= line_points; j++) {
                    // Interpolate circle size for each point
                    float point_position = map(j, 0, line_points - 1, 0, 1);
                    float x = bezierPoint(p1x, h1x, h2x, p2x, point_position);
                    float y = bezierPoint(p1y, h1y, h2y, p2y, point_position);
                    
                    // Noise rotate about position
                    PVector pt = new PVector(x, y);
                    PVector h = new PVector(noise_scale, 0);
                    h.rotate(noise(x * noise_factor, y * noise_factor) * 2 * TWO_PI);
                    
                    PVector pOut = PVector.add(pt, h);
                    
                    if (debug_mode) {
                        noStroke();
                        fill(128,128,128, 40);
                        circle(x, y, noise_scale * 2);
                        
                        stroke(1);
                        strokeWeight(1);
                        line(pt.x, pt.y, pOut.x, pOut.y);
                    }
                    
                    vertex(pOut.x, pOut.y);
                }
                
                stroke(1);
                strokeWeight(stroke_weight);
                noFill();
                
                endShape();
            }
            // Apply transform
            rotate(radians(vortex_rotation));
            scale(1 - ((float) a / vortex_iterations * 0.5f));
        }

        popMatrix();

    }
    
    public void drawHandles() {
        if (show_handles) {
            pushMatrix();
            translate(width * 0.5f, height * 0.5f);

            // Handles
            noStroke();
            fill(255,0,0);
            circle(v1.x, v1.y, handle_size);
            circle(v3.x, v3.y, handle_size);
            circle(v2.x, v2.y, handle_size);
            circle(v4.x, v4.y, handle_size);
            
            fill(0,255,0);
            circle(h1.x, h1.y, handle_size);
            circle(h2.x, h2.y, handle_size);
            circle(h3.x, h3.y, handle_size);
            circle(h4.x, h4.y, handle_size);
            
            fill(0,0,255);
            circle(c1.x, c1.y, handle_size);
            circle(c2.x, c2.y, handle_size);
            circle(c3.x, c3.y, handle_size);
            circle(c4.x, c4.y, handle_size);
            
            noFill();
            strokeWeight(1);
            stroke(255,0,0);
            
            // Bezier Lines
            line(v1.x, v1.y, h1.x, h1.y);
            line(h1.x, h1.y, h2.x, h2.y);
            line(h2.x, h2.y, v2.x, v2.y);
            
            line(v3.x, v3.y, h3.x, h3.y);
            line(h3.x, h3.y, h4.x, h4.y);
            line(h4.x, h4.y, v4.x, v4.y);
            
            // Distort controls
            stroke(0,0,255);
            line(v1.x, v1.y, c1.x, c1.y);
            line(v3.x, v3.y, c2.x, c2.y);
            line(v2.x, v2.y, c3.x, c3.y);
            line(v4.x, v4.y, c4.x, c4.y);

            popMatrix();
        }
    }
    

    public void checkSelection() {
        PVector m = new PVector(mouseX - width / 2, mouseY - height / 2);
        
        if (mousePressed == false ) {
            selected_vector = null;
        }

        if (selected_vector == null) {
            // Check for mouse hvoer
            pushMatrix();
            translate(width * 0.5f, height * 0.5f);
            for (int i = 0; i < vectors.length; i++) {
                if (m.dist(vectors[i]) < handle_size / 2) {
                    selected_vector = vectors[i];
                    noStroke();
                    fill(0, 150);
                    circle(selected_vector.x, selected_vector.y, handle_size);
                    break;
                }
                
            }
            popMatrix();
        } else {
            // Apply new position
            if (mousePressed == true) {
                selected_vector.x = m.x;
                selected_vector.y = m.y;
            }
        }
    }

    
    public void assignVectorArray() {
        vectors[0] = v1;
        vectors[1] = v2;
        vectors[2] = v3;
        vectors[3] = v4;
        vectors[4] = h1;
        vectors[5] = h2;
        vectors[6] = h3;
        vectors[7] = h4;
        vectors[8] = c1;
        vectors[9] = c2;
        vectors[10] = c3;
        vectors[11] = c4;
    } 
} 


  public void settings() { size(800, 800);
smooth(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Nautilae_06" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
